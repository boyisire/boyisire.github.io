<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>数据库使用规范 - 大业的大业</title><link rel="icon" type="image/png" href=icons/myicon.png /><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="数据库使用规范" />
<meta property="og:description" content="Mysql" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://boyisire.github.io/posts/database-mysql/" />
<meta property="article:published_time" content="2019-08-08T18:18:57+08:00" />
<meta property="article:modified_time" content="2019-08-08T18:18:57+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据库使用规范"/>
<meta name="twitter:description" content="Mysql"/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="https://boyisire.github.iocss/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://boyisire.github.iocss/main.css" />
	<link rel="stylesheet" type="text/css" href="https://boyisire.github.iocss/custom.css" />
	<link rel="stylesheet" type="text/css" href="https://boyisire.github.iocss/dark.css" media="(prefers-color-scheme: dark)" />
	<link rel="stylesheet" type="text/css" href="https://boyisire.github.iocss/custom-dark.css" media="(prefers-color-scheme: dark)" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<script src="https://boyisire.github.iojs/main.js"></script>
	<script src="https://boyisire.github.iojs/abc.js"></script>
	<script src="https://boyisire.github.iojs/xyz.js"></script>
	<script src="https://code.jquery.com/jquery-3.4.1.js"></script>
</head>

<body>
	<div class="container wrapper post">
		<div class="header">
	<base href="https://boyisire.github.io">
	<h1 class="site-title"><a href="https://boyisire.github.io">大业的大业</a></h1>
	<div class="site-description"><h2>记录精彩瞬间</h2><nav class="nav social">
			<ul class="flat"><a href="https://github.com/vividvilla/ezhil" title="Github"><i data-feather="github"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post-header">
			<h1 class="title">数据库使用规范</h1>
			<div class="meta">Posted at &mdash; Aug 8, 2019</div>
		</div>

		<div class="markdown">
			<h1 id="1-引言">1. 引言</h1>
<p>良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计schema, 这往往需要权衡各种因素。
制定数据库设计规范规范的直接目的是约束设计行为，最终目的是确保设计的合理统一,保障项目最终的协调稳定性。规范虽然是有丰富项目经验的人制定的，但维护的却不是某个人的意志，而是项目的意志，因为遵守此规范对项目是好的有利的，此规范才有意义。所以规范是为了项目利益最大化而在团队人员中形成的一种约定，所有参与设计的人员都要遵守此约定，所有参与开发的人员都会依此约定解读设计。我们希望团队中所有人看到设计成果，一眼就可以明白这个字段是做什么的、代表的含义是什么，可以但不止于见名知意。</p>
<h1 id="2-说明">2. 说明</h1>
<h2 id="21-编写目的">2.1 编写目的</h2>
<p>使用统一的命名和编码规范，使数据库命名及编码风格标准化，以便于阅读、理解和继承。</p>
<h2 id="22-能愿动词">2.2 能愿动词</h2>
<p>为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下：</p>
<ul>
<li>必须（Must） - 只能这样子做，请无条件遵循，没有别的选项；</li>
<li>绝不（Must Not）- 严令禁止，在任何情况下都不能这样做；</li>
<li>应该（Should） - 强烈建议这样做，但是不强求；</li>
<li>不应该（Should Not） - 强烈建议不这样做，但是不强求；</li>
<li>可以（May） - 选择性高一点，在这个文档内，此词语使用较少；</li>
</ul>
<h2 id="23-关于执行">2.3 关于执行</h2>
<p>在这份规范里，有些内容里会解释『这样做的理由』，这样做的目的是为了达成共识。</p>
<blockquote>
<p>请不要以此『理由』的准确性来怀疑规范的权威性，规范就是规范，可以讨论改正，但在执行的时候 <code>必须</code>严格遵守。</p>
</blockquote>
<ul>
<li>原则: 约定优先于配置（Convention Over Configuration）</li>
</ul>
<p>请把『团队项目开发』想象就是在行军打仗，对于规范要绝对服从。要有大局观，做到团结一致，把个人的喜好放一边，把整个团队的执行效率放在第一位。</p>
<h1 id="3-适用范围">3. 适用范围</h1>
<p>本规范适用于公司范围内所有后台数据库应用系统和项目开发工作。</p>
<h1 id="4-数据库设计">4. 数据库设计</h1>
<h2 id="41-命名规范">4.1 命名规范</h2>
<p>命名规范是指数据库对象如数据库（SCHEMA）、表（TABLE）、索引（INDEX）、约束（CONSTRAINTS）等的命名约定。</p>
<h3 id="411-基本规范">4.1.1 基本规范</h3>
<ul>
<li>所有数据库对象<code>必须</code>使用小写字母</li>
<li>命名只能使用英文字母、数字、下划线，<code>绝不</code>使用驼峰式方式命名</li>
<li><code>必须</code>使用有意义的英文词汇，词汇中间以下划线分隔，<code>绝不</code>使用汉语拼音</li>
<li>为了避免书写SQL语句时,忽略数据库对象上加``的情况，<code>不应该</code>使用MySQL的保留字</li>
</ul>
<blockquote>
<p>如:desc、index、range、match等,具体可参考<a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html">MySQL 官方保留字</a></p>
</blockquote>
<h3 id="412-数据库命名规范">4.1.2 数据库命名规范</h3>
<ul>
<li>数据库名<code>绝不</code>能超过30个字符</li>
<li>数据库命名<code>必须</code>为项目名称(英文单词或有意义的简写）+ 具体的<!-- raw HTML omitted --><code>使用环境</code><!-- raw HTML omitted -->简称。如：<code>jzh-online</code></li>
<li>数据库备份命名规则：<code>dbbak_数据库名_日期</code></li>
</ul>
<h3 id="413-数据表命名规范">4.1.3 数据表命名规范</h3>
<ul>
<li>表名<code>不应该</code>取得太长（一般不超过三个英文单词）,<code>绝不</code>能超过30个字符</li>
<li>同一个模块的表<code>应该</code>使用相同的前缀，表名称<code>应该</code>尽可能表达含义</li>
</ul>
<blockquote>
<p>为了尽可能不影响表的命名，表前缀<code>应该</code>越短越好</p>
</blockquote>
<ul>
<li>表名<code>应该</code>使用名词或者动宾短语,<code>必须</code>使用复数形式表示</li>
</ul>
<blockquote>
<p>例如：使用 <strong>employees</strong>，而不是 <strong>employee</strong>
原因：项目使用了 <em>PHP Laravel</em> 框架,该框架数据表多用该风格，因此用此风格保证一致性</p>
</blockquote>
<h4 id="4131-表命名规则">4.1.3.1 表命名规则</h4>
<h5 id="41311-普通表命名规则">4.1.3.1.1 普通表命名规则</h5>
<p>模块名_表描述（或有意义的简写）</p>
<p><strong>命名示例</strong></p>
<table>
<thead>
<tr>
<th>错误</th>
<th>正确</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>USERS</td>
<td>users</td>
<td>未使用小写</td>
</tr>
<tr>
<td>USER</td>
<td>user</td>
<td>未使用复数</td>
</tr>
<tr>
<td>jzh_live_recomments</td>
<td>live_recomments</td>
<td>无项添加项目前缀</td>
</tr>
</tbody>
</table>
<h5 id="41312-临时表命名规则">4.1.3.1.2 临时表命名规则</h5>
<p>运营、开发或数据库人员临时用作数据采集用的中间表
<strong>命名规则:</strong> <code>tmp_表名_8位时间后缀</code></p>
<blockquote>
<p>如：tmp_users_20190401</p>
</blockquote>
<h5 id="41313-备份表命名规则">4.1.3.1.3 备份表命名规则</h5>
<p>运营、开发或数据库人员备份用作保存历史数据的中间表
<strong>命名规则:</strong> <code>bak_表名_8位时间后缀</code></p>
<blockquote>
<p>如：bak_users_20190401</p>
</blockquote>
<h5 id="41314-待删除表命名规则">4.1.3.1.4 待删除表命名规则</h5>
<p>进行数据表转换拷贝时，会生成一些待删除的表，故对其单独处理.在日期后，1个月内将该表删除
<strong>命名规则:</strong> <code>del_表名_8位时间后缀</code></p>
<blockquote>
<p>如：del_users_20190401</p>
</blockquote>
<h4 id="4132-常用表前缀">4.1.3.2 常用表前缀</h4>
<table>
<thead>
<tr>
<th>前缀</th>
<th>释义</th>
<th>样例</th>
</tr>
</thead>
<tbody>
<tr>
<td>sys_</td>
<td>系统配置模块</td>
<td>sys_configs</td>
</tr>
<tr>
<td>dict_</td>
<td>字典类模块</td>
<td>dict_regions</td>
</tr>
<tr>
<td>user_</td>
<td>用户模块</td>
<td>user_msgs</td>
</tr>
<tr>
<td>admin_</td>
<td>后台模块</td>
<td>admin_users</td>
</tr>
<tr>
<td>order_</td>
<td>订单模块</td>
<td>order_records</td>
</tr>
<tr>
<td>live_</td>
<td>讲座模块</td>
<td>live_msgs</td>
</tr>
</tbody>
</table>
<h3 id="414-表字段命名规范">4.1.4 表字段命名规范</h3>
<ul>
<li>字段命名<code>必须</code>使用有实际含义的英文单词完整名称，<code>绝不</code>使用缩写</li>
<li>布尔值字段,<code>必须</code>以<code>is_+字段描述</code>的方式命名</li>
<li>各表之间相同意义的字段，<code>应该</code>以<strong>去掉模块前缀的表名_字段名</strong>命名。如：<code>user_id</code></li>
<li>外键字段<code>应该</code>用<strong>表名_字段名</strong>表示其关联关系</li>
<li><code>绝不</code>在列的名称中包含数据类型</li>
<li>字段名称中,<code>不应该</code>再重复表名称</li>
</ul>
<p><strong>命名示例</strong></p>
<table>
<thead>
<tr>
<th>错误</th>
<th>正确</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>userID</td>
<td>user_id</td>
<td>大小写规则不统一</td>
</tr>
<tr>
<td>isgood</td>
<td>is_good</td>
<td>加下划线规则不统一</td>
</tr>
</tbody>
</table>
<h3 id="415-索引命名规范">4.1.5 索引命名规范</h3>
<ul>
<li>非唯一索引索引<code>必须</code>以idx_开头，如要在id列上添加二级索引，则应为idx_id。</li>
<li>唯一索引<code>必须</code>以<code>uniq_</code>开头。后面紧跟索引所在的字段名。</li>
<li>多单词组成的列名，如果太长，可取尽可能代表意义的缩写，如test_contact表member_id和friend_id上的组合索引：idx_mid_fid。</li>
<li>组合索引命名应注意字段顺序。如在字段member和字段userid上创建组合索引，则可以命名为idx_userid_member(‘userid’,‘member’)</li>
</ul>
<h3 id="416-约束命名规范">4.1.6 约束命名规范</h3>
<ul>
<li>主键约束：pk_</li>
<li>唯一约束：uk_表名称_字段名。</li>
<li>外键约束：fk_表名，后面紧跟该外键所在的表名和对应的主表名（不含t_）.子表名和父表名用下划线(_)分隔。</li>
<li>非空约束：如无特殊需要，建议所有字段默认非空(not null)，不同数据类型必须给出默认值(default)。</li>
</ul>
<blockquote>
<p>出于性能考虑，如无特殊需要，建议不使用外键。参照完整性由代码控制。</p>
</blockquote>
<h3 id="417-视图命名规范">4.1.7 视图命名规范</h3>
<ul>
<li>视图名以<code>view_名称</code></li>
</ul>
<blockquote>
<p>视图由几个表关联产生就用下划线（_）连接几个表名，视图名不能超过30个字符。如超过30个字符则取简写。</p>
</blockquote>
<p><strong>注：</strong> 如无特殊需要，严禁开发人员创建视图。</p>
<h3 id="418-存储过程命名规范">4.1.8 存储过程命名规范</h3>
<ul>
<li>存储过程(procedure)名<code>必须</code>以<code>proc_+过程名</code></li>
</ul>
<blockquote>
<p>多个单词以下划线（_）进行连接。存储过程命名中应体现其功能。存储过程名不能超过30个字符。</p>
</blockquote>
<ul>
<li>存储过程中的输入参数以i_开头，输出参数以o_开头。</li>
</ul>
<h3 id="419-函数命名规范">4.1.9 函数命名规范</h3>
<ul>
<li>函数(function)名<code>必须</code>以<code>func_方法</code>。</li>
</ul>
<blockquote>
<p>多个单词以下划线（_）进行连接，函数命名中应体现其功能。函数名不能超过30个字符。</p>
</blockquote>
<ul>
<li>函数中输入参数以i_开头，输出参数以o_开头。</li>
</ul>
<h3 id="4110-触发器命名规范">4.1.10 触发器命名规范</h3>
<ul>
<li>触发器(trigger)以<code>tri_</code>开头，表示。</li>
<li>后缀（_i,_u,_d）,表示触发条件的触发方式（insert,update或delete）。</li>
</ul>
<p><em>如无特殊需要，严禁开发人员使用触发器。</em></p>
<h3 id="4111-sql语言编码规范">4.1.11 SQL语言编码规范</h3>
<ul>
<li>大小写规范
<ul>
<li>所有关键字必须大写，如：INSERT、UPDATE、DELETE、SELECT及其子句，IF……ELSE、CASE、DECLARE等</li>
<li>所有函数及其参数中除用户变量以外的部分必须大写</li>
<li>在定义变量时用到的数据类型必须小写</li>
</ul>
</li>
</ul>
<h3 id="4112-注释">4.1.12 注释</h3>
<ul>
<li>所有表必须添加中文注释名称</li>
<li>所有字段必须添加字段释义</li>
</ul>
<h2 id="42-对象设计">4.2 对象设计</h2>
<h3 id="421-表设计">4.2.1 表设计</h3>
<ul>
<li>数据库创建时必须添加默认字符集和校对规则子句。默认字符集为UTF8MB4</li>
<li>表引擎取决于实际应用场景；日志及报表类表建议用myisam，与交易，审核，金额相关的表建议用innodb引擎。如无说明，建表时一律采用innodb引擎</li>
<li>默认使用utf8mb4字符集，数据库排序规则使用utf8mb4_general_ci（由于数据库定义使用了默认，数据表可以不再定义，但为保险起见，建议都写上）。</li>
<li>所有表、字段均应用 comment 列属性来描述此表、字段所代表的真正含义</li>
<li>主键。如无说明，表中的第一个id字段一定是主键且为自动增长，禁止在非事务内作为上下文作为条件进行数据传递。禁止使用varchar类型作为主键语句设计。</li>
<li>单条记录大小禁止超过8k（列长度(中文)*3(UTF8)+列长度(英文)*1）,即：列总大度小于<code>65535</code></li>
<li>禁止在数据库中存储明文密码</li>
</ul>
<h3 id="422-数据类型">4.2.2 数据类型</h3>
<p><strong>原则：</strong></p>
<ul>
<li>更小的通常更好</li>
</ul>
<blockquote>
<p>一般情况下，应该尽量选择使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为它们占用更小的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少</p>
</blockquote>
<ul>
<li>简单就好</li>
</ul>
<blockquote>
<p>简单数据类型的操作通常需要更少的CPU周期。
例如，整形比字符串操作代价更低，因为字符集和校对规则（排序规则）使字符串比整形比较更复杂。
这里有两个例子：一个是应该使用MySQL内建的类型而不是字符串来存储日期和时间，另一个是应该使用整形存储IP地址。</p>
</blockquote>
<ul>
<li>尽量避免NULL</li>
</ul>
<blockquote>
<p>通常情况下<code>应该</code>指定列为NOT NULL，除非真的需要存储NULL值。因为查询中包含可以NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、统计索引和值比较都更为复杂。同时，可为NULL的列被索引时，每个索引记录需要一个额外的字节。当列设为<code>非NULL</code>时,<code>必须</code>有默认值。其中在无明确说明的情况下，字符型的默认值为一个空字符值串<code>''</code>，数值型的默认值为数值<code>0</code>。</p>
</blockquote>
<ul>
<li>整数类型</li>
</ul>
<blockquote>
<p>TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT分别使用8、16、24、32、64位存储空间，它们可以存储的值的范围从-2(N-1)到2(N-1)-1，其中N是存储空间的位数。</p>
</blockquote>
<ul>
<li>
<p>在可用的情况下，用合适的字段类型节约存储空间,占用空间越小，优先级越高</p>
</li>
<li>
<p>如无特殊情况，所有字符型和数值型全设为非NULL,同时赋与默认值</p>
</li>
<li>
<p>实数类型</p>
</li>
</ul>
<blockquote>
<p>FLOAT使用4个字节、DOUBLE使用8个字节、DECIMAL使用9个字节。因为需要额外的空间和计算开销，所以<code>应该</code>尽量只在对小数进行精确计算时才使用DECIMAL。</p>
</blockquote>
<ul>
<li>字符类型</li>
</ul>
<blockquote>
<p>定长类的字段,<code>应该</code>统一使用char(m),变长类的<code>应该</code>使用<code>varchar(m)</code>，且m的值越小越好，够用即可，别预留太多。<code>text</code>类型，能不用尽量不使用，如果varchar不能代替，则<code>应该</code>单独提出一个表,做为附属表来配合使用。</p>
</blockquote>
<p><strong>设计:</strong></p>
<ul>
<li>主键字段。<code>必须</code>放在表的第一列，需自增，非NULL。其中，大部分表统一使用无符号int(10); 部分系统配置、数据字典类小表(记录小于65535)使用smallint(5)。</li>
</ul>
<blockquote>
<p>例：
<code>id int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键id'</code>
<code>id smallint(5) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键id'</code></p>
</blockquote>
<ul>
<li>逻辑判断型字段,<code>必须</code>以<code>is_</code>开头命名，类型用<code>tinyint(4)</code>,其中,数值<code>0</code>表示&quot;假&quot;，数值<code>1</code>表示&quot;真
&quot;</li>
</ul>
<blockquote>
<p>例：<code>is_del tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否删除:0-否,1-是</code></p>
</blockquote>
<ul>
<li>表示状态、分类、枚举型字段,<code>必须</code>使用<code>tinyint(4)</code></li>
</ul>
<blockquote>
<p>例：
<code>status tinyint(4) NOT NULL DEFAULT 1 COMMENT '状态:0-禁用,1-启用'</code>
<code>type tinyint(4) NOT NULL DEFAULT 0 COMMENT '操作类型:0-文字,1-图片,2-语音'</code></p>
</blockquote>
<ul>
<li>排序类字段<code>应该</code>使用<code>sort</code>或者以<code>sort_</code>开头命名，<code>可以</code>使用类型<code>smallint(6)</code></li>
</ul>
<blockquote>
<p>例：
<code>smallint(6) NOT NULL DEFAULT 0 COMMENT '排序标识(越小越靠前)'</code></p>
</blockquote>
<ul>
<li>日期类字段,<code>应该</code>使用<code>timestamp</code>类型,<code>不应该</code>使用字符串类型来代替。如无特殊情况，表<code>必须</code>包含<code>created_at</code>和<code>updated_at</code>字段，来表示记录创建和修改时间;部分有删除需求的表,<code>必须</code>以<code>deleted_at</code>，做为删除标识,用删除时间是否为空，来判断记录是否删除(原则上不允许直接删除表记录)</li>
</ul>
<blockquote>
<p>注：datetime、smalldatetime类型的字段,占用空间相对较大，且无法设置默认值，故如果特殊，尽量不使用
例：
<code>created_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'</code>
<code>updated_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间'</code>
<code>deleted_at timestamp NULL DEFAULT NULL</code></p>
</blockquote>
<h3 id="423-索引设计">4.2.3 索引设计</h3>
<p>MySQL的查询速度依赖良好的索引设计，因此索引对于高性能至关重要。合理的索引会加快查询速度（包括UPDATE和DELETE的速度，MySQL会将包含该行的page加载到内存中，然后进行UPDATE或者DELETE操作），不合理的索引会降低速度。MySQL索引查找类似于新华字典的拼音和部首查找，当拼音和部首索引不存在时，只能通过一页一页的翻页来查找。当MySQL查询不能使用索引时，MySQL会进行全表扫描，会消耗大量的IO。
<strong>索引的用途:</strong></p>
<ul>
<li>去重</li>
<li>加速定位</li>
<li>避免排序、覆盖索引</li>
</ul>
<p><strong>索引的优点:</strong></p>
<ul>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将所及I/O变为顺序I/O</li>
</ul>
<h4 id="4231-索引的基本规范">4.2.3.1 索引的基本规范</h4>
<ol>
<li>索引数量控制</li>
</ol>
<blockquote>
<p>单张表中索引数量,<code>应该</code>不超过5个，单个索引中的字段数不超过5个。</p>
<ul>
<li>综合评估数据密度和分布</li>
<li>考虑查询和更新比例</li>
</ul>
</blockquote>
<ol start="2">
<li>对字符串使用前缀索引，前缀索引长度不超过8个字符，建议优先考虑前缀索引，必要时可添加伪列并建立索引</li>
</ol>
<blockquote>
<p>不要索引blob/text等字段,不要索引大型字段,这样做会让索引占用太多的存储空间</p>
</blockquote>
<ol start="3">
<li>主键准则</li>
</ol>
<ul>
<li>表必须有主键</li>
<li>不使用更新频繁的列</li>
<li>尽量不选择字符串列</li>
<li>不使用UUID MD5 HASH</li>
<li>默认使用非空的唯一键</li>
<li>建议选择自增或发号器</li>
</ul>
<ol start="4">
<li>重要的SQL必须被索引，核心SQL优先考虑覆盖索索引</li>
</ol>
<ul>
<li>UPDATE、DELETE语句的WHERE条件列</li>
<li>ORDER BY、GROUP BY、DISTINCT的字段</li>
<li>多表JOIN的字段</li>
</ul>
<ol start="5">
<li>区分度最大的字段放在前面</li>
</ol>
<ul>
<li>选择筛选性更优的字段放在最前面，比如单号、userid等，type，status等筛选性一般不建议放在最前面</li>
<li>索引根据左前缀原则，当建立一个联合索引(a,b,c)，则查询条件里面只有包含(a)或(a,b)或(a,b,c)的时候才能走索引,(a,c)作为条件的时候只能使用到a列索引,所以这个时候要确定a的返回列一定不能太多，不然语句设计就不合理,(b,c)则不能走索引</li>
<li>合理创建联合索引（避免冗余），(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)</li>
</ul>
<ol start="6">
<li>索引禁忌</li>
</ol>
<ul>
<li>不在低基数列上建立索引，例如“性别”</li>
<li>不在索引列进行数学运算和函数运算</li>
<li>不要索引常用的小型表</li>
</ul>
<ol start="7">
<li>尽量不使用外键</li>
</ol>
<ul>
<li>外键用来保护参照完整性，可在业务端实现</li>
<li>对父表和子表的操作会相互影响，降低可用性</li>
<li>INNODB本身对online DDL的限制</li>
</ul>
<h4 id="4232--mysql-中索引的使用限制">4.2.3.2  MYSQL 中索引的使用限制</h4>
<ul>
<li>MYISAM 存储引擎索引长度的总和不能超过 1000 字节</li>
<li>BLOB 和 TEXT 类型的列只能创建前缀索引</li>
<li>MYSQL 目前不支持函数索引</li>
<li>使用不等于 (!= 或者 &lt;&gt;) 的时候, MYSQL 无法使用索引。</li>
<li>过滤字段使用函数运算 (如 abs (column)) 后, MYSQL无法使用索引。</li>
<li>join语句中join条件字段类型不一致的时候MYSQL无法使用索引</li>
<li>使用 LIKE 操作的时候如果条件以通配符开始 (如 ‘%abc…’)时, MYSQL无法使用索引。</li>
<li>使用非等值查询的时候, MYSQL 无法使用 Hash 索引。</li>
</ul>
<h3 id="424-sql语句设计规范">4.2.4 SQL语句设计规范</h3>
<ol>
<li>使用预编译语句</li>
</ol>
<ul>
<li>只传参数，比传递SQL语句更高效</li>
<li>一次解析，多次使用</li>
<li>降低SQL注入概率</li>
</ul>
<ol start="2">
<li>避免隐式转换</li>
</ol>
<blockquote>
<p>会导致索引失效</p>
</blockquote>
<ol start="3">
<li>充分利用前缀索引</li>
</ol>
<ul>
<li>必须是最左前缀</li>
<li>不可能同时用到两个范围条件</li>
<li>不使用%前导的查询，如like “%ab”</li>
</ul>
<ol start="4">
<li>不使用负向查询，如not in/like</li>
</ol>
<ul>
<li>无法使用索引，导致全表扫描</li>
<li>全表扫描导致buffer pool利用率降低</li>
</ul>
<ol start="5">
<li>避免使用存储过程、触发器、UDF、events等
+让数据库做最擅长的事</li>
</ol>
<ul>
<li>降低业务耦合度，为sacle out、sharding留有余地</li>
<li>避开BUG</li>
</ul>
<ol start="6">
<li>避免使用大表的JOIN</li>
</ol>
<ul>
<li>MySQL最擅长的是单表的主键/二级索引查询</li>
<li>JOIN消耗较多内存，产生临时表</li>
</ul>
<ol start="7">
<li>避免在数据库中进行数学运算</li>
</ol>
<ul>
<li>MySQL不擅长数学运算和逻辑判断</li>
<li>无法使用索引</li>
</ul>
<ol start="8">
<li>减少与数据库的交互次数</li>
</ol>
<ul>
<li>INSERT … ON DUPLICATE KEY UPDATE</li>
<li>REPLACE INTO、INSERT IGNORE 、INSERT INTO VALUES(),(),()</li>
<li>UPDATE … WHERE ID IN(10,20,50,…)</li>
</ul>
<ol start="9">
<li>合理的使用分页</li>
</ol>
<ul>
<li>限制分页展示的页数</li>
<li>只能点击上一页、下一页</li>
<li>采用延迟关联</li>
</ul>
<ol start="9">
<li>拒绝大SQL，拆分成小SQL</li>
</ol>
<ul>
<li>充分利用QUERY CACHE</li>
<li>充分利用多核CPU</li>
</ul>
<ol start="10">
<li>
<p>使用in代替or，in的值不超过1000个</p>
</li>
<li>
<p>禁止使用order by rand()</p>
</li>
<li>
<p>使用EXPLAIN诊断，避免生成临时表</p>
</li>
</ol>
<blockquote>
<p>EXPLAIN语句（在MySQL客户端中执行）可以获得MySQL如何执行SELECT语句的信息。通过对SELECT语句执行EXPLAIN，可以知晓MySQL执行该SELECT语句时是否使用了索引、全表扫描、临时表、排序等信息。尽量避免MySQL进行全表扫描、使用临时表、排序等。详见官方文档。</p>
</blockquote>
<ol start="13">
<li>
<p>用union all而不是union</p>
</li>
<li>
<p>程序应有捕获SQL异常的处理机制</p>
</li>
<li>
<p>禁止单条SQL语句同时更新多个表</p>
</li>
<li>
<p>不使用select * ，SELECT语句只获取需要的字段</p>
</li>
</ol>
<ul>
<li>消耗CPU和IO、消耗网络带宽</li>
<li>无法使用覆盖索引</li>
<li>减少表结构变更带来的影响</li>
<li>因为大，select/join 可能生成临时表</li>
</ul>
<ol start="17">
<li>
<p>UPDATE、DELETE语句不使用LIMIT</p>
</li>
<li>
<p>INSERT语句必须显式的指明字段名称，不使用INSERT INTO table()</p>
</li>
<li>
<p>INSERT语句使用batch提交（INSERT INTO table VALUES(),(),()……），values的个数不超过500</p>
</li>
<li>
<p>统计表中记录数时使用COUNT(*)，而不是COUNT(primary_key)和COUNT(1) 备注：仅针对Myisam</p>
</li>
<li>
<p>数据更新建议使用二级索引先查询出主键，再根据主键进行数据更新</p>
</li>
<li>
<p>禁止使用跨库查询</p>
</li>
<li>
<p>禁止使用子查询，建议将子查询转换成关联查询</p>
</li>
<li>
<p>针对varchar类型字段的程序处理，请验证用户输入，不要超出其预设的长度；</p>
</li>
</ol>
<h3 id="425-分表规范">4.2.5 分表规范</h3>
<p>单表一到两年内数据量超过500w或数据容量超过10G考虑分表，需提前考虑历史数据迁移或应用自行删除历史数据，采用等量均衡分表或根据业务规则分表均可。要分表的数据表必须与DBA商量分表策略</p>
<ul>
<li>用HASH进行散表，表名后缀使用十进制数，下标从0开始</li>
<li>按日期时间分表需符合YYYY[MM][DD][HH]格式</li>
<li>采用合适的分库分表策略。例如千库十表、十库百表等</li>
<li>禁止使用分区表，分区表对分区键有严格要，分区表在表变大后执行DDL、SHARDING、单表恢复等都变得更加困难。</li>
<li>拆分大字段和访问频率低的字段，分离冷热数据</li>
</ul>
<h3 id="426-行为规范">4.2.6 行为规范</h3>
<ul>
<li>批量导入、导出数据必须提前通知DBA协助观察</li>
<li>禁止在线上从库执行后台管理和统计类查询</li>
<li>禁止有super权限的应用程序账号存在</li>
<li>产品出现非数据库导致的故障时及时通知DBA协助排查</li>
<li>推广活动或上线新功能必须提前通知DBA进行流量评估</li>
<li>数据库数据丢失，及时联系DBA进行恢复</li>
<li>对单表的多次alter操作必须合并为一次操作</li>
<li>不在MySQL数据库中存放业务逻辑</li>
<li>重大项目的数据库方案选型和设计必须提前通知DBA参与</li>
<li>对特别重要的库表，提前与DBA沟通确定维护和备份优先级</li>
<li>不在业务高峰期批量更新、查询数据库</li>
<li>提交线上建表改表需求，必须详细注明所有相关SQL语句</li>
</ul>
<h3 id="427-其他规范">4.2.7 其他规范</h3>
<p>日志类数据不建议存储在MySQL上，优先考虑Hbase或OceanBase，如需要存储请找DBA评估使用压缩表存储。</p>
<h1 id="5-常用sql">5. 常用SQL</h1>
<h3 id="创建索引">创建索引</h3>
<blockquote>
<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引</p>
</blockquote>
<ul>
<li><code>ALTER TABLE table_name ADD PRIMARY KEY (column_list);</code></li>
</ul>
<h4 id="添加主键索引">添加主键索引</h4>
<blockquote>
<p>PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引。这表示一个表只能包含一个PRIMARY KEY，因为一个表中不可能具有两个同名的索引。</p>
</blockquote>
<h4 id="添加普通索引">添加普通索引</h4>
<ul>
<li><code>ALTER TABLE table_name ADD INDEX index_name (column_list);</code></li>
<li><code>CREATE INDEX index_name ON table_name (column_list);</code></li>
</ul>
<h4 id="添加唯一性索引">添加唯一性索引</h4>
<ul>
<li><code>ALTER TABLE table_name ADD UNIQUE (column_list);</code></li>
<li><code>CREATE UNIQUE INDEX index_name ON table_name (column_list);</code></li>
</ul>
<h3 id="删除索引">删除索引</h3>
<p>如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p>
<p>可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下。</p>
<ul>
<li><code>DROP INDEX index_name ON talbe_name;</code></li>
<li><code>ALTER TABLE table_name DROP INDEX index_name;</code></li>
<li><code>ALTER TABLE table_name DROP PRIMARY KEY;</code></li>
</ul>
<h3 id="查看索引">查看索引</h3>
<p>mysql&gt; show index from tblname;</p>
<p>mysql&gt; show keys from tblname;</p>
<h2 id="注释">注释</h2>
<h3 id="表注释">表注释</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> <span style="color:#719e07">`</span>users<span style="color:#719e07">`</span> <span style="color:#719e07">COMMENT</span> <span style="color:#2aa198">&#39;用户表&#39;</span>;
</code></pre></div><ol>
<li>修改表名称</li>
</ol>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> <span style="color:#719e07">&lt;</span>表名<span style="color:#719e07">&gt;</span> <span style="color:#719e07">RENAME</span> <span style="color:#719e07">&lt;</span>新表名<span style="color:#719e07">&gt;</span>mysql<span style="color:#719e07">&gt;</span> <span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> game_account <span style="color:#719e07">RENAME</span> account;
</code></pre></div><ol start="2">
<li>修改表的存储引擎</li>
</ol>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> account ENGINE<span style="color:#719e07">=</span>MyISAM;
</code></pre></div><ol start="3">
<li>添加字段</li>
</ol>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> <span style="color:#719e07">&lt;</span>表名<span style="color:#719e07">&gt;</span> <span style="color:#719e07">ADD</span> <span style="color:#719e07">&lt;</span>字段名称<span style="color:#719e07">&gt;</span> <span style="color:#719e07">&lt;</span>字段定义<span style="color:#719e07">&gt;</span>

例：
<span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> account <span style="color:#719e07">ADD</span> Account_gender ENUM(<span style="color:#2aa198">&#34;M&#34;</span>,<span style="color:#2aa198">&#34;F&#34;</span>) <span style="color:#719e07">NOT</span> <span style="color:#719e07">NULL</span>;
<span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> account <span style="color:#719e07">ADD</span> Game_zone <span style="color:#b58900">VARCHAR</span>(<span style="color:#2aa198">20</span>) <span style="color:#719e07">NOT</span> <span style="color:#719e07">NULL</span> <span style="color:#719e07">DEFAULT</span> <span style="color:#2aa198">&#34;HuaBei&#34;</span> <span style="color:#719e07">FIRST</span>;
<span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> account <span style="color:#719e07">ADD</span> Account_money <span style="color:#b58900">BIGINT</span> <span style="color:#719e07">AFTER</span> Account_level;
</code></pre></div><ol start="4">
<li>删除字段</li>
</ol>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> <span style="color:#719e07">&lt;</span>表名<span style="color:#719e07">&gt;</span> <span style="color:#719e07">DROP</span> <span style="color:#719e07">&lt;</span>字段名称<span style="color:#719e07">&gt;</span>

例：
<span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> account <span style="color:#719e07">DROP</span> Account_role ;
</code></pre></div><ol start="5">
<li>修改字段名称及字段定义</li>
</ol>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> <span style="color:#719e07">&lt;</span>表名<span style="color:#719e07">&gt;</span> CHANGE <span style="color:#719e07">&lt;</span>旧字段名称<span style="color:#719e07">&gt;</span> <span style="color:#719e07">&lt;</span>新字段名称<span style="color:#719e07">&gt;</span> <span style="color:#719e07">&lt;</span>字段定义<span style="color:#719e07">&gt;</span>

例：
<span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> account CHANGE Account_password password <span style="color:#b58900">CHAR</span>(<span style="color:#2aa198">25</span>) <span style="color:#719e07">NOT</span> <span style="color:#719e07">NULL</span>;
<span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> account CHANGE password password <span style="color:#b58900">VARCHAR</span>(<span style="color:#2aa198">60</span>) ;
</code></pre></div><ol start="6">
<li>修改字段定义</li>
</ol>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> <span style="color:#719e07">&lt;</span>表名<span style="color:#719e07">&gt;</span> <span style="color:#719e07">MODIFY</span> <span style="color:#719e07">&lt;</span>字段名称<span style="color:#719e07">&gt;</span> <span style="color:#719e07">&lt;</span>字段定义<span style="color:#719e07">&gt;</span>

例：
<span style="color:#719e07">ALTER</span> <span style="color:#719e07">TABLE</span> account <span style="color:#719e07">MODIFY</span> Account_name <span style="color:#b58900">VARCHAR</span>(<span style="color:#2aa198">20</span>) <span style="color:#719e07">NOT</span> <span style="color:#719e07">NULL</span>;
</code></pre></div><h3 id="查看mysql库大小表大小索引大小">查看mysql库大小，表大小，索引大小</h3>
<blockquote>
<p>说明：
通过MySQL的 <code>information_schema</code> 数据库，可查询数据库中每个表占用的空间、表记录的行数；该库中有一个 <code>TABLES</code> 表，这个表主要字段分别是：</p>
</blockquote>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">CREATE TEMPORARY TABLE `TABLES` (
  `TABLE_CATALOG` varchar(512) NOT NULL DEFAULT &#39;&#39;,
  `TABLE_SCHEMA` varchar(64) NOT NULL DEFAULT &#39;&#39;,
  `TABLE_NAME` varchar(64) NOT NULL DEFAULT &#39;&#39;,
  `TABLE_TYPE` varchar(64) NOT NULL DEFAULT &#39;&#39;,
  `ENGINE` varchar(64) DEFAULT NULL,
  `VERSION` bigint(21) unsigned DEFAULT NULL,
  `ROW_FORMAT` varchar(20) DEFAULT NULL,
  `TABLE_ROWS` bigint(21) unsigned DEFAULT NULL,
  `AVG_ROW_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `DATA_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `MAX_DATA_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `INDEX_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `DATA_FREE` bigint(21) unsigned DEFAULT NULL,
  `AUTO_INCREMENT` bigint(21) unsigned DEFAULT NULL,
  `CREATE_TIME` datetime DEFAULT NULL,
  `UPDATE_TIME` datetime DEFAULT NULL,
  `CHECK_TIME` datetime DEFAULT NULL,
  `TABLE_COLLATION` varchar(32) DEFAULT NULL,
  `CHECKSUM` bigint(21) unsigned DEFAULT NULL,
  `CREATE_OPTIONS` varchar(255) DEFAULT NULL,
  `TABLE_COMMENT` varchar(2048) NOT NULL DEFAULT &#39;&#39;
) ENGINE=MEMORY DEFAULT CHARSET=utf8;
</code></pre></div><ul>
<li>TABLE_SCHEMA : 数据库名</li>
<li>TABLE_NAME：表名</li>
<li>ENGINE：所使用的存储引擎</li>
<li>TABLES_ROWS：记录数</li>
<li>DATA_LENGTH：数据大小</li>
<li>INDEX_LENGTH：索引大小</li>
</ul>
<blockquote>
<p>其他字段请参考MySQL的手册，查看一个表占用空间的大小，那就相当于是 数据大小 + 索引大小 。</p>
</blockquote>
<h4 id="查表的大小和空间">查表的大小和空间</h4>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">select `TABLE_SCHEMA`,`TABLE_NAME`,`TABLE_ROWS`,concat(round(sum(DATA_LENGTH/1024/1024),2),&#39;MB&#39;) as MB  from `information_schema`.`TABLES` where table_schema=&#39;jzh-prod&#39; group by TABLE_NAME order by DATA_LENGTH desc;

</code></pre></div><h4 id="查看所有库的大小">查看所有库的大小</h4>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">select concat(round(sum(DATA_LENGTH/1024/1024),2),&#39;MB&#39;) as data  from `information_schema`.`TABLES`;
</code></pre></div><h4 id="查看指定库的大小">查看指定库的大小</h4>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">select concat(round(sum(DATA_LENGTH/1024/1024),2),&#39;MB&#39;) as data  from `information_schema`.`TABLES` where table_schema=&#39;jishi&#39;;
</code></pre></div><h4 id="查看指定库的指定表的大小">查看指定库的指定表的大小</h4>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">select concat(round(sum(DATA_LENGTH/1024/1024),2),&#39;MB&#39;) as data  from `information_schema`.`TABLES` where table_schema=&#39;jishi&#39; and table_name=&#39;a_ya&#39;;
</code></pre></div><h4 id="查看指定库的索引大小">查看指定库的索引大小</h4>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">SELECT CONCAT(ROUND(SUM(index_length)/(1024*1024), 2), &#39; MB&#39;) AS &#39;Total Index Size&#39; FROM `information_schema`.`TABLES`  WHERE table_schema = &#39;jishi&#39;;
</code></pre></div><h4 id="查看指定库的指定表的索引大小">查看指定库的指定表的索引大小</h4>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">SELECT CONCAT(ROUND(SUM(index_length)/(1024*1024), 2), &#39; MB&#39;) AS &#39;Total Index Size&#39; FROM `information_schema`.`TABLES`  WHERE table_schema = &#39;test&#39; and table_name=&#39;a_yuser&#39;;
</code></pre></div><h4 id="查看一个库中的情况">查看一个库中的情况</h4>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">SELECT CONCAT(table_schema,&#39;.&#39;,table_name) AS &#39;Table Name&#39;, CONCAT(ROUND(table_rows/1000000,4),&#39;M&#39;) AS &#39;Number of Rows&#39;, CONCAT(ROUND(data_length/(1024*1024*1024),4),&#39;G&#39;) AS &#39;Data Size&#39;, CONCAT(ROUND(index_length/(1024*1024*1024),4),&#39;G&#39;) AS &#39;Index Size&#39;, CONCAT(ROUND((data_length+index_length)/(1024*1024*1024),4),&#39;G&#39;) AS&#39;Total&#39;FROM information_schema.TABLES WHERE `information_schema`.`table_schema` LIKE &#39;test&#39;;
</code></pre></div><h1 id="6-答疑解惑">6. 答疑解惑</h1>
<ul>
<li>为什么库、表、字段全部采用小写</li>
</ul>
<blockquote>
<p>在 MySQL 中，数据库和表对就于那些目录下的目录和文件。因而，操作系统的敏感性决定数据库和表命名的大小写敏感。
Windows下是不区分大小写的。
Linux下大小写规则：
数据库名与表名是严格区分大小写的；
表的别名是严格区分大小写的；
列名与列的别名在所有的情况下均是忽略大小写的；
变量名也是严格区分大小写的；
如果已经设置了驼峰式的命名如何解决？需要在MySQL的配置文件my.ini中增加 lower_case_table_names = 1即可。</p>
</blockquote>
<ul>
<li>为什么字符集不选择utf8，排序规则不使用utf8_general_ci</li>
</ul>
<blockquote>
<p>采用utf8编码的MySQL无法保存占位是4个字节的Emoji表情。为了使后端的项目，全面支持客户端输入的Emoji表情，升级编码为utf8mb4是最佳解决方案。对于JDBC连接串设置了characterEncoding为utf8或者做了上述配置仍旧无法正常插入emoji数据的情况，需要在代码中指定连接的字符集为utf8mb4。</p>
</blockquote>
<ul>
<li>datetime与timestamp有什么不同</li>
</ul>
<blockquote>
<p>相同点：TIMESTAMP列的显示格式与DATETIME列相同。显示宽度固定在19字符，并且格式为YYYY-MM-DD HH:MM:SS。
不同点：
TIMESTAMP
4个字节储存，时间范围：1970-01-01 08:00:01 ~ 2038-01-19 11:14:07
值以UTC格式保存，涉及时区转化 ，存储时对当前的时区进行转换，检索时再转换回当前的时区。
datetime
8个字节储存，时间范围：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
实际格式储存，与时区无关
如何使用TIMESTAMP的自动赋值属性
将当前时间作为ts的默认值：ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP。
当行更新时，更新ts的值：ts TIMESTAMP DEFAULT  ON UPDATE CURRENT_TIMESTAMP。
可以将1和2结合起来：ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP。</p>
</blockquote>
<ul>
<li>如何使用INT UNSIGNED存储ip</li>
</ul>
<blockquote>
<p>使用INT UNSIGNED而不是char(15)来存储ipv4地址，通过MySQL函数inet_ntoa和inet_aton来进行转化。Ipv6地址目前没有转化函数，需要使用DECIMAL或者两个bigINT来存储。</p>
</blockquote>
<ul>
<li>什么时候用CHAR，什么时候用VARCHAR</li>
</ul>
<blockquote>
<p>CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。CHAR和VARCHAR类型声明的长度表示你想要保存的最大字符数。例如，CHAR(30)可以占用30个字符。
CHAR列的长度固定为创建表时声明的长度。长度可以为从0到255的任何值。当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。
VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值。(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。
同CHAR对比，VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。
char适合存储用户密码的MD5哈希值，它的长度总是一样的。对于经常改变的值，char也好于varchar,因为固定长度的行不容易产生碎片，对于很短的列，char的效率也高于varchar。char(1)字符串对于单字节字符集只会占用一个字节，但是varchar(1)则会占用2个字节，因为1个字节用来存储长度信息。以下情况使用VARCAHR是合适的：字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都是使用不同的字节数进行存储。
<strong>注意</strong>，在使用VARCHAR时最好的策略时只分配真正需要的空间。因为更长的列会消耗更多的内存，MYSQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作时特别糟糕，在利用磁盘临时表进行排序时也同样糟糕。</p>
</blockquote>
<ul>
<li>什么是覆盖索引</li>
</ul>
<blockquote>
<p>InnoDB存储引擎中，secondary index（非主键索引）中没有直接存储行地址，存储主键值。如果用户需要查询secondary index中所不包含的数据列时，需要先通过secondary index查找到主键值，然后再通过主键查询到其他数据列，因此需要查询两次。覆盖索引的概念就是查询可以通过在一个索引中完成，覆盖索引效率会比较高，主键查询是天然的覆盖索引。合理的创建索引以及合理的使用查询语句，当使用到覆盖索引时可以获得性能提升。比如SELECT email,uid FROM user_email WHERE uid=xx，如果uid不是主键，适当时候可以将索引添加为index(uid,email)，以获得性能提升。</p>
</blockquote>
<ul>
<li>为什么一张表中不能存在过多的索引</li>
</ul>
<blockquote>
<p>InnoDB的secondary index使用b+tree来存储，因此在UPDATE、DELETE、INSERT的时候需要对b+tree进行调整，过多的索引会减慢更新的速度。</p>
</blockquote>
<ul>
<li>什么是前缀索引</li>
</ul>
<blockquote>
<p>前缀索引说白了就是对文本的前几个字符（具体是几个字符在建立索引时指定）建立索引，这样建立起来的索引更小，所以查询更快。 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)。
建立前缀索引的语法：ALTER TABLE table_name ADD KEY(column_name(prefix_length));</p>
</blockquote>
<ul>
<li>INT[M]，M值代表什么含义</li>
</ul>
<blockquote>
<p>注意数值类型括号后面的数字只是表示宽度而跟存储范围没有关系。很多人他们认为INT(4)和INT(10)其取值范围分别是 (-9999到9999)和(-9999999999到9999999999)，这种理解是错误的。其实对整型中的 M值与 ZEROFILL 属性结合使用时可以实现列值等宽。不管INT[M]中M值是多少，其取值范围还是 (-2147483648到2147483647 有符号时)，(0到4294967295无符号时)。
显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。当结合可选扩展属性ZEROFILL使用时默认补充的空格用零代替。例如：对于声明为INT(5) ZEROFILL的列，值4检索为00004。请注意如果在整数列保存超过显示宽度的一个值，当MySQL为复杂联接生成临时表时会遇到问题，因为在这些情况下MySQL相信数据适合原列宽度，如果为一个数值列指定ZEROFILL, MySQL自动为该列添加UNSIGNED属性。</p>
</blockquote>
<ul>
<li>int(10)与int(11) 的区别</li>
</ul>
<blockquote>
<p><code>int(11)</code>能够存储的实际最大值为 <code>4294967296</code>，这个数字，一共有<code>10</code>位，故<code>int(10)</code>可用,常用于<code>无符号</code>整型列上;
使用<code>int(11)</code>的原因是,在有符号整型的情况下,数值最小的可能是 <code>-2147483648</code> ,故<code>int(11)</code>可用,其主要用在<code>有符号</code>整型列上。</p>
</blockquote>
<ul>
<li>如何正确的使用分页</li>
</ul>
<blockquote>
<p>假如有类似下面分页语句：SELECT * FROM table  ORDER BY id LIMIT 10000, 10
由于MySQL里对LIMIT OFFSET的处理方式是取出OFFSET+LIMIT的所有数据，然后去掉OFFSET，返回底部的LIMIT。所以，在OFFSET数值较大时，MySQL的查询性能会非常低。可以使用id &gt; n 的方式进行解决：
使用id &gt; n 的方式有局限性，对于id不连续的问题，可以通过翻页的时候同时传入最后一个id方式来解决。
这种方式比较大的缺点是，如果在浏览中有插入/删除操作，翻页不会更新，而总页数可能仍然是根据新的count(*) 来计算，最终可能会产生某些记录访问不到。为了修补这个问题，可以继续引入当前页码以及在上次翻页以后是否有插入/删除等影响总记录数的操作并进行缓存
其他变种方式：
select * from table where id &gt;= (select id from table order by id limit #offset#, 1)</p>
</blockquote>
<ul>
<li>union all与 union有什么区别？</li>
</ul>
<blockquote>
<p>union和union all关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。
union在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。如：</p>
</blockquote>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">select * from test_union1
union
select * from test_union2
</code></pre></div><p>这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。
而union all只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。
从效率上说，union all要比union快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用union all，如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">select * from test_union1
union all
select * from test_union2
</code></pre></div><h1 id="7-附录">7. 附录</h1>
<h2 id="1-mysql中unicode字符集列表">1. MySQL中Unicode字符集列表</h2>
<table>
<thead>
<tr>
<th>字符集名称</th>
<th>字节占用</th>
<th>字符集兼容性</th>
<th>Unicode字符支持</th>
</tr>
</thead>
<tbody>
<tr>
<td>UCS2</td>
<td>每字符2字节</td>
<td></td>
<td>所有Unicode 3.0字符</td>
</tr>
<tr>
<td>UTF16</td>
<td>每字符2字节，或4字节</td>
<td>与UCS2兼容</td>
<td>所有Unicode 5.0和Unicode 6.0字符，包括扩展字符</td>
</tr>
<tr>
<td>UTF16LE</td>
<td>与UTF16相同，只是字节顺序相反</td>
<td></td>
<td>所有Unicode 5.0和Unicode 6.0字符，包括扩展字符</td>
</tr>
<tr>
<td>UTF8</td>
<td>每字符1到3字节</td>
<td></td>
<td>所有Unicode 3.0字符</td>
</tr>
<tr>
<td>UTF8MB4</td>
<td>每字符1到4字节</td>
<td>与UTF8兼容</td>
<td>所有Unicode 5.0和Unicode 6.0字符，包括扩展字符</td>
</tr>
<tr>
<td>UTF32</td>
<td>每字符4字节</td>
<td></td>
<td>所有Unicode 5.0和Unicode 6.0字符，包括扩展字符</td>
</tr>
</tbody>
</table>
<h2 id="数据库类型范围表">数据库类型范围表</h2>
<h3 id="整型">整型</h3>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用字节数</th>
<th>有符号范围(SIGNED)</th>
<th>无符号范围(UNSIGNED)</th>
</tr>
</thead>
<tbody>
<tr>
<td>tinyint(m)</td>
<td>1</td>
<td>[-2^7, 2^7-1] =&gt; -128~127</td>
<td>[0, 2^8-1] =&gt; 0~255</td>
</tr>
<tr>
<td>smallint(m)</td>
<td>2</td>
<td>[-2^15, 2^15-1] =&gt; -32768~32767</td>
<td>[0, 2^16-1] =&gt; 0~65535</td>
</tr>
<tr>
<td>mediumint(m)</td>
<td>3</td>
<td>[-2^23, 2^23-1] =&gt; -8388608~8388607</td>
<td>[0, 2^14-1] =&gt; 0~16777215</td>
</tr>
<tr>
<td>int(m)</td>
<td>4</td>
<td>[-2^31, 2^31-1] =&gt; -2147483648~2147483647</td>
<td>[0, 2^32-1] =&gt; 0~4294967295</td>
</tr>
<tr>
<td>bigint(m)</td>
<td>8</td>
<td>[-2^63, 2^63 -1] =&gt; -9233372036854775808~9223372036854775807</td>
<td>[0,2^64-1] =&gt; 0~18446744073709551615</td>
</tr>
</tbody>
</table>
<blockquote>
<p>m表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围</p>
</blockquote>
<h3 id="日期类型">日期类型</h3>
<p>MySQL 的日期类型有5个，分别是： date、time、year、datetime、timestamp。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>格式</th>
<th>用途</th>
<th>是否支持设置系统默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>date</td>
<td>3</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
<td>不支持</td>
</tr>
<tr>
<td>time</td>
<td>3</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
<td>不支持</td>
</tr>
<tr>
<td>year</td>
<td>1</td>
<td>YYYY</td>
<td>年份</td>
<td>不支持</td>
</tr>
<tr>
<td>datetime</td>
<td>8</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>日期和时间混合值</td>
<td>不支持</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>YYYYMMDD HHMMSS</td>
<td>混合日期和时间，可作时间戳</td>
<td>支持</td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于 default 设置，通常情况下会使用当前时间作为默认值
只有timestamp可设置默认值，常用值有<code>NOW()</code>和<code>CURRENT_TIMESTAMP()</code></p>
</blockquote>
<h3 id="数据库环境说明a-idhead">数据库环境说明<!-- raw HTML omitted --></h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>英文</th>
<th>简写</th>
<th>使用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发环境</td>
<td>Development Environment</td>
<td>dev</td>
<td>开发可读写，开发人员可以修改表结构，可以随意修改其中的数据；但是需要保证不影响其他开发同事</td>
</tr>
<tr>
<td>测试环境</td>
<td>Test Environment</td>
<td>qa</td>
<td>开发可读写，部署的测试系统访问此库，代测试人员使用</td>
</tr>
<tr>
<td>模拟环境</td>
<td>Simulation Environment</td>
<td>sim</td>
<td>开发可读写，通过web平台，发起上线请求时，会先在这个环境上进行预执行，这个环境也可供部署上线演练或压力测试使用</td>
</tr>
<tr>
<td>线上从库</td>
<td>Real Environment</td>
<td>real</td>
<td>只读，会准实时的从线上数据库同步，不允许修改数据，不允许修改表结构。供线上问题查找，数据查询等使用</td>
</tr>
<tr>
<td>线上环境</td>
<td>Online Environment</td>
<td>online</td>
<td>开发人员不允许直接在线上环境进行数据库操作，如果需要操作必须找数据库主负责人，并做相应记录。禁止进行压力测试</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这些环境的机器，视公司业务情况，不一定会全部用到，但一定要做到权限划分明确，读写帐号分离，并且有辨识度，能区分具体业务。例如用户名w_account，r_ account 分别代表读、写账号，account是读写账号。</p>
</blockquote>
<h2 id="数据库常用函数">数据库常用函数</h2>
<h3 id="日期类">日期类</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>样例</th>
</tr>
</thead>
<tbody>
<tr>
<td>NOW()</td>
<td>返回当前的日期和时间</td>
<td>2019-04-28 18:00:00</td>
</tr>
<tr>
<td>CURDATE()</td>
<td>返回当前的日期</td>
<td>2019-04-28</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前的时间</td>
<td>18:00:00</td>
</tr>
</tbody>
</table>
<h3 id="常用表字段">常用表字段</h3>
<table>
<thead>
<tr>
<th>字段名</th>
<th>释义</th>
<th>类型</th>
<th>是否为空</th>
<th>默认值</th>
<th>使用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>主键ID</td>
<td>int(10) unsigned AUTO_INCREMENT</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>created_at</td>
<td>创建时间</td>
<td>timestamp</td>
<td>否</td>
<td>CURRENT_TIMESTAMP</td>
<td>须放列尾</td>
</tr>
<tr>
<td>updated_at</td>
<td>修改时间</td>
<td>timestamp</td>
<td>否</td>
<td>CURRENT_TIMESTAMP</td>
<td>须放列尾</td>
</tr>
<tr>
<td>deleted_at</td>
<td>删除时间</td>
<td>timestamp</td>
<td>是</td>
<td>NULL</td>
<td>须放列尾</td>
</tr>
<tr>
<td>sort</td>
<td>排序</td>
<td>smallint(6)</td>
<td>否</td>
<td>0</td>
<td>数值越小,排名越前</td>
</tr>
</tbody>
</table>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>
<p><a href="https://learnku.com/docs/laravel-specification/5.5/whats-the-use-of-standards/510"> Laravel 项目开发规范 </a></p>
</li>
<li>
<p><a href="https://shuwoom.com/?p=2563"> MySQL性能优化学习笔记 </a></p>
</li>
<li>
<p><a href="https://learnku.com/articles/25020"> MySQL规范 </a></p>
</li>
<li>
<p><a href="https://learnku.com/articles/25270"> MySQL 避坑宝典 &ndash; 来自小米的开源工具 </a></p>
</li>
<li>
<p><a href="http://www.52im.net/thread-2157-1-1.html"> 史上最全MySQL大表优化方案总结 </a></p>
</li>
</ul>

		</div>

		<div class="post-tags">
			
				
					<nav class="nav tags">
							<ul class="flat">
								
								<li><a href="/tags/specification">specification</a></li>
								
							</ul>
					</nav>
				
			
		</div>
		</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> © Copyright notice |  <a href="https://github.com/vividvilla/ezhil">Ezhil theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-123-45', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>feather.replace()</script>
</body>
</html>
